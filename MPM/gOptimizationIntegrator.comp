#version 450 core

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

/* begin MPM shaders header */
const int GRID_SIZE_X = 32*4;
const int GRID_SIZE_Y = 32*4;

struct materialPoint {
	vec2 x;
	vec2 v;
	float m;
	float vol;
	mat2 B;
	mat2 F;
	mat2 P;
};

layout (std430, binding = 1) buffer pointCloud {
	readonly materialPoint points[];
};

uniform float dt = 1/60.0;

struct gridNode {
	float m;
	float opengl_padding;
	vec2 v;
};

layout (std430, binding = 2) buffer particleGrid {
	gridNode nodes[GRID_SIZE_X][GRID_SIZE_Y];
};

/* end MPM shaders header */
float BSpline(in float x);
float BSplineSlope(in float x);

uniform vec2 gravity = vec2(0.0, -9.8);
uniform mat2 Dp_inv = 3 * mat2(1.0); // Should be 4 for quadratic B-Spline, but 3 is giving me more realistic results
uniform vec2 globalForce = vec2(0.0, 0.0);


void main() {

	vec2 nodePos = vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
	uvec2 node = uvec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y); // grid node index

	uint N = points.length();

	float nodeMass = 0.0;
	vec2 nodeMomentum = vec2(0.0);
	vec2 nodeForce = vec2(0.0);
	
	// P2G
	for (uint p = 0; p < N; ++p) {
		vec2 dpg = nodePos - points[p].x;
		float dx = -dpg.x; // sign matters for gradient
		float dy = -dpg.y;
		float wpg = BSpline(dx) * BSpline(dy);
		vec2 wpgGrad = vec2(BSplineSlope(dx) * BSpline(dy),
							BSpline(dx) * BSplineSlope(dy));

		nodeMass += wpg * points[p].m;
		nodeMomentum += wpg * points[p].m * (points[p].v + points[p].B * Dp_inv * dpg);
		nodeForce -= points[p].vol * points[p].P * transpose(points[p].F) * wpgGrad;
	}

	// Final steps of P2G
	nodes[node.x][node.y].m = nodeMass;
	nodes[node.x][node.y].v = (nodeMass == 0.0) ? vec2(0.0) : nodeMomentum/nodeMass + dt*(nodeForce/nodeMass + gravity + globalForce);

	// compute collisions
	// for (uint i = 0; i < num_PC-1; ++i) {
	// 	for (uint j = i+1; j < num_PC-2; ++j){
	// 		vec2 v1i = Vg[i][node.x][node.y];
	// 		vec2 v2i = Vg[j][node.x][node.y];
	// 		float collide = dot(v1i, v2i);

	// 		float m1 = Mg[i][node.x][node.y];
	// 		float m2 = Mg[j][node.x][node.y];

	// 		float massSum = m1+m2;
	// 		float massDiff = m1-m2;
	// 		vec2 v1f = (massSum == 0.0) ? vec2(0.0) : (massDiff*v1i + 2*m2*v2i) / massSum;
	// 		vec2 v2f = (massSum == 0.0) ? vec2(0.0) : (2*m1*v1i - massDiff*v2i) / massSum;

	// 		Vg[i][node.x][node.y] = (collide <= 0.0) ? v1i : v1f;
	// 		Vg[j][node.x][node.y] = (collide <= 0.0) ? v2i : v2f;
	// 	}
	// }

	// after all invocations run, Mg and Vg have been successfully written
}