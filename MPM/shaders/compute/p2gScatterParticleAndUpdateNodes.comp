#version 450 core
#extension GL_NV_shader_atomic_float64 : enable

layout (local_size_x = 1024) in;

/*** HEADER ***/

// uniform int selectedNodeI;
// uniform int selectedNodeJ;

void main() {

	uint pid = gl_GlobalInvocationID.x;
	uint N = points.length();
	if (pid > N) {
		return;
	}

	dvec2 xp = points[pid].x;

	int botLeftNode_i = int(floor(xp.x)) - 1;
	int botLeftNode_j = int(floor(xp.y)) - 1;

	// For visualizing bspline proximity to selected node
	// dvec2 selectDpg = dvec2(selectedNodeI, selectedNodeJ) - xp;
	// points[pid].selectedWpg = BSpline(selectDpg.x) * BSpline(selectDpg.y);

	for (int i = 0; i <= 3; ++i) {
		for (int j = 0; j <= 3; ++j) {
			int curNode_i = botLeftNode_i + i;
			int curNode_j = botLeftNode_j + j;
			double inb = 1.0;
			InBounds(curNode_i, curNode_j, inb);

			dvec2 dpg = dvec2(curNode_i, curNode_j) - xp;
			double dx = -dpg.x; // sign matters for gradient
			double dy = -dpg.y;
			double wpg = BSpline(dx) * BSpline(dy);
			dvec2 wpgGrad = dvec2(BSplineSlope(dx) * BSpline(dy),
								BSpline(dx) * BSplineSlope(dy));

			atomicAdd(nodes[curNode_i][curNode_j].m, wpg * points[pid].m);

			barrier();

			//points[pid].B = dmat2(0.0);
			//points[pid].P = dmat2(0.0);

			dvec2 momentumAdd = wpg * points[pid].m * (points[pid].v + points[pid].B * Dp_inv * dpg);
			atomicAdd(nodes[curNode_i][curNode_j].momentum.x, momentumAdd.x);
			atomicAdd(nodes[curNode_i][curNode_j].momentum.y, momentumAdd.y);

			barrier();

			dvec2 forceAdd = -points[pid].vol * points[pid].P * transpose(points[pid].Fe) * wpgGrad;
			atomicAdd(nodes[curNode_i][curNode_j].force.x, forceAdd.x);
			atomicAdd(nodes[curNode_i][curNode_j].force.y, forceAdd.y);

			barrier();
		}
	}
}