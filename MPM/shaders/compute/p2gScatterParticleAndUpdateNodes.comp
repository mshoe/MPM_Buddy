#version 450 core
#extension GL_NV_shader_atomic_float64 : enable

layout (local_size_x = 1024) in;

/*** HEADER ***/

// uniform int selectedNodeI;
// uniform int selectedNodeJ;



void main() {

	uint pid = gl_GlobalInvocationID.x;
	uint N = points.length();
	if (pid > N) {
		return;
	}

	dvec2 xp = points[pid].x;

	int botLeftNode_i = int(floor(xp.x)) - 1;
	int botLeftNode_j = int(floor(xp.y)) - 1;

	// For visualizing bspline proximity to selected node
	// dvec2 selectDpg = dvec2(selectedNodeI, selectedNodeJ) - xp;
	// points[pid].selectedWpg = BSpline(selectDpg.x) * BSpline(selectDpg.y);

	for (int i = 0; i <= 3; ++i) {
		for (int j = 0; j <= 3; ++j) {
			int curNode_i = botLeftNode_i + i;
			int curNode_j = botLeftNode_j + j;
			double inb = 1.0;
			InBounds(curNode_i, curNode_j, inb);

			dvec2 dpg = dvec2(curNode_i, curNode_j) - xp;
			double dx = -dpg.x; // sign matters for gradient
			double dy = -dpg.y;
			double wpg = BSpline(dx) * BSpline(dy);
			

			atomicAdd(nodes[curNode_i][curNode_j].m, wpg * points[pid].m);

			barrier();

			dvec2 momentumAdd;
			// B is used for APIC transfer
			if (transferScheme == APIC || transferScheme == MLS)  { // APIC, MLS also uses APIC
				momentumAdd = wpg * points[pid].m * (points[pid].v + points[pid].B * dpg);
			// } else if (transferScheme == MLS) {
			// 	momentumAdd = wpg * points[pid].m * (points[pid].B * dpg);
			} else if (transferScheme == RPIC) { // RPIC
				
				dmat3 Kp_inv = 3.0 * dmat3(1.0);
				dvec3 momentumAdd3D = cross(Kp_inv * dvec3(0.0, 0.0, points[pid].Lz), dvec3(dpg, 0.0));
				momentumAdd = wpg * points[pid].m * (points[pid].v + momentumAdd3D.xy);

			} else if (transferScheme == PIC) { // PIC
				momentumAdd = wpg * points[pid].m * points[pid].v;
			}
			atomicAdd(nodes[curNode_i][curNode_j].momentum.x, momentumAdd.x);
			atomicAdd(nodes[curNode_i][curNode_j].momentum.y, momentumAdd.y);

			barrier();

			dvec2 forceAdd;
			if (transferScheme == MLS) { // MLS doesn't need wpgGrad
				forceAdd = -Dp_inv * points[pid].vol * points[pid].P * transpose(points[pid].Fe) * dpg * wpg;
			}
			else {
				dvec2 wpgGrad = dvec2(BSplineSlope(dx) * BSpline(dy),
								BSpline(dx) * BSplineSlope(dy));
				forceAdd = -points[pid].vol * points[pid].P * transpose(points[pid].Fe) * wpgGrad;
			}
			atomicAdd(nodes[curNode_i][curNode_j].force.x, forceAdd.x);
			atomicAdd(nodes[curNode_i][curNode_j].force.y, forceAdd.y);

			barrier();
		}
	}
}