#version 450 core

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

/* begin MPM shaders header */
const int GRID_SIZE_X = 32*4;
const int GRID_SIZE_Y = 32*4;

uniform float dt = 1/60.0;

struct gridNode {
	float m;
	float opengl_padding;
	vec2 v;
	vec2 momentum;
	vec2 force;
};

layout (std430, binding = 1) buffer particleGrid1 {
	gridNode nodes1[GRID_SIZE_X][GRID_SIZE_Y];
};

layout (std430, binding = 2) buffer particleGrid2 {
	gridNode nodes2[GRID_SIZE_X][GRID_SIZE_Y];
};
/* end MPM shaders header */

// Simple Elastic collision of two bodies, compute on the nodes that overlap

void main() {
	uvec2 node = uvec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y); // grid node index

	

	// if (m1 == 0.0 || m2 == 0.0) {
	// 	return; // no collision to compute
	// }

	vec2 v1i = nodes1[node.x][node.y].v;
	vec2 v2i = nodes2[node.x][node.y].v;

	if (dot(v1i, v2i) >= 0.0) {
		return; // point clouds are separting, don't compute collision
	}

	float m1 = nodes1[node.x][node.y].m;
	float m2 = nodes2[node.x][node.y].m;

	float massSum = m1 + m2;
	float massDiff = m1 - m2;

	//vec2 v1f = (massDiff*v1i + 2*m2*v2i)/massSum;
	//vec2 v2f = (2*m1*v1i - massDiff*v2i)/massSum;

	vec2 v1f = (massSum == 0.0) ? v1i : (massDiff*v1i + 2*m2*v2i) / massSum;
	vec2 v2f = (massSum == 0.0) ? v2i : (2*m1*v1i - massDiff*v2i) / massSum;

	nodes1[node.x][node.y].v = v1f;
	nodes2[node.x][node.y].v = v2f;

}