/* begin MPM shaders header */
const int GRID_SIZE_X = 32*4;
const int GRID_SIZE_Y = 32*4;

struct materialPoint {
	vec2 x;
	vec2 v;
	float m;
	float vol;
	mat2 B;
	mat2 F;
	mat2 P;
};

struct gridNode {
	float m;
	float opengl_padding;
	vec2 v;
	vec2 momentum;
	vec2 force;

	// for implicit time step / conjugate residuals	
	vec2 deltaForce;
	vec2 xk; // velocity guess
	vec2 rk;
	vec2 pk;
	vec2 Ark;
	vec2 Apk;

	float rkArk;
	float glsl_padding2;
};

layout (std430, binding = 1) buffer pointCloud {
	materialPoint points[];
};


layout (std430, binding = 2) buffer particleGrid {
	gridNode nodes[GRID_SIZE_X][GRID_SIZE_Y];
};

float QuadBSpline(in float x) {
	x = abs(x);
	return (x < 0.5) ? 	step(0.0, x)*(0.75 - x*x) :
						step(x, 1.5)*0.5*(1.5 - x)*(1.5-x);
}

float QuadBSplineSlope(in float x) {
	float absx = abs(x);
	return (absx < 0.5) ? 	step(0.0, absx)*(-2*x) : 
						step(absx, 1.5)*(x - 1.5*x/absx);
}

float BSpline(in float x) {
	x = abs(x);
	return (x < 1.0) ? 	step(0.0, x)*(0.5*x*x*x - x*x + 2.0/3.0) :
						step(x, 2.0)*(2.0-x)*(2.0-x)*(2.0-x)/6.0;
}

float BSplineSlope(in float x) {
	float absx = abs(x);
	return (absx < 1.0) ? 	step(0.0, absx)*(1.5*x*absx-2*x) : 
						step(absx, 2.0)*(-x*absx/2 + 2*x - 2*x/absx);
}

void InBounds(inout int i, inout int j, out float inbounds) {
	float r1 = float(int((0 <= i) && (i < GRID_SIZE_X)));
	float r2 = float(int((0 <= j) && (j < GRID_SIZE_Y)));
	inbounds = r1 * r2;

	// also sets i and j to 0 if they are out of bounds, 
	// so they don't produce an error when accessing arrays
	i = (inbounds != 0.0) ? i : 0;
	j = (inbounds != 0.0) ? j : 0;
}

void PolarDecomp(in mat2 F, out mat2 R, out mat2 S) {
	// calculate the polar decomposition F = RS.

	float x = F[0][0] + F[1][1];
	float y = F[0][1] - F[1][0]; // glsl is column major. This is really F_21 - F_12 in row major notation

	float d = sqrt(x*x + y*y);

	float c = x/d;
	float s = -y/d;
	R = (d == 0.0) ? mat2(1.0, 0.0, 0.0, 1.0) : mat2(c, -s, s, c);
	S = transpose(R) * F;
}

mat2 cofactorMatrix(in mat2 X) {
	return mat2(X[1][1], -X[1][0], // column 1
				-X[0][1], X[0][0]); // column 2
}

float innerProduct(in mat2 X, in mat2 Y) {
	return X[0][0]*Y[0][0] + X[1][0]*Y[1][0] + X[0][1]*Y[0][1] + X[1][1]*Y[1][1];
}

bool isnanVec2(in vec2 v) {
	return isnan(v.x) || isnan(v.y);
}

bool isinfVec2(in vec2 v) {
	return isinf(v.x) || isinf(v.y);
}

uniform float dt = 1/60.0;

uniform mat2 Dp_inv = 3 * mat2(1.0); // Should be 4 for quadratic B-Spline, but 3 is giving me more realistic results
uniform vec2 gravity = vec2(0.0, -9.8);
uniform vec2 globalForce = vec2(0.0, 0.0);

uniform float mew = 41.6667;
uniform float lam = 27.7778;

const uint NEO_HOOKEAN = 0;
const uint FIXED_COROTATED = 1;
uniform uint comodel = 1; //FIXED_COROTATED;

uniform float IMPLICIT_RATIO = 1.0;
uniform float drag = 0.005;

/* end MPM shaders header */