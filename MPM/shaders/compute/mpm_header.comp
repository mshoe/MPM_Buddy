/* begin MPM shaders header */
const int GRID_SIZE_X = 32*4;
const int GRID_SIZE_Y = 32*4;
int CHUNK_WIDTH = 32;
uniform int CHUNKS_X = 4;
uniform int CHUNKS_Y = 4;

struct materialPoint {
	dvec2 x;
	dvec2 v;
	double m;
	double vol;
	dmat2 B;
	dmat2 Fe;
	dmat2 Fp;
	dmat2 P;

	// extra not neccessary to store, but useful for debugging
	dmat2 FePolar_R;
	dmat2 FePolar_S;
	dmat2 FeSVD_U;
	dmat2 FeSVD_S;
	dmat2 FeSVD_V;
	dmat2 A;

	double energy;
	double selectedWpg;
};

struct gridNode {
	double m;
	double opengl_padding;
	dvec2 v;
	dvec2 momentum;
	dvec2 force;
	dvec2 nodalAcceleration;

	// for implicit time step / conjugate residuals	
	dvec2 deltaForce;
	dvec2 xk; // velocity guess
	dvec2 rk;
	dvec2 pk;
	dvec2 Ark;
	dvec2 Apk;

	double rkArk;
	bool converged;
	bool selected;
};

layout (std430, binding = 1) buffer pointCloud {
	materialPoint points[];
};


layout (std430, binding = 2) buffer particleGrid {
	gridNode nodes[GRID_SIZE_X][GRID_SIZE_Y];
};

int GetGridNodeIndex(int node_i, int node_j) {
	return node_i * CHUNKS_Y * CHUNK_WIDTH + node_j;
}

double QuadBSpline(in double x) {
	x = abs(x);
	return (x < 0.5) ? 	step(0.0, x)*(0.75 - x*x) :
						step(x, 1.5)*0.5*(1.5 - x)*(1.5-x);
}

double QuadBSplineSlope(in double x) {
	double absx = abs(x);
	return (absx < 0.5) ? 	step(0.0, absx)*(-2*x) : 
						step(absx, 1.5)*(x - 1.5*x/absx);
}

double BSpline(in double x) {
	x = abs(x);
	return (x < 1.0) ? 	step(0.0, x)*(0.5*x*x*x - x*x + 2.0/3.0) :
						step(x, 2.0)*(2.0-x)*(2.0-x)*(2.0-x)/6.0;
}

double BSplineSlope(in double x) {
	double absx = abs(x);
	return (absx < 1.0) ? 	step(0.0, absx)*(1.5*x*absx-2*x) : 
						step(absx, 2.0)*(-x*absx/2 + 2*x - 2*x/absx);
}

void InBounds(inout int i, inout int j, out double inbounds) {
	double r1 = double(int((0 <= i) && (i < CHUNK_WIDTH * CHUNKS_X)));
	double r2 = double(int((0 <= j) && (j < CHUNK_WIDTH * CHUNKS_Y)));
	inbounds = r1 * r2;

	// also sets i and j to 0 if they are out of bounds, 
	// so they don't produce an error when accessing arrays
	i = (inbounds != 0.0) ? i : 0;
	j = (inbounds != 0.0) ? j : 0;
}

bool isnanVec2(in dvec2 v) {
	return isnan(v.x) || isnan(v.y);
}

bool isinfVec2(in dvec2 v) {
	return isinf(v.x) || isinf(v.y);
}

uniform double dt = 1/60.0;

uniform dmat2 Dp_inv = 3 * dmat2(1.0); // 3 * dx^2 * I
uniform dvec2 gravity = dvec2(0.0, -9.81);
uniform dvec2 globalForce = dvec2(0.0, 0.0);

uniform double mew = 41.66666667;
uniform double lam = 27.77777778;

const uint NEO_HOOKEAN = 0;
const uint FIXED_COROTATED = 1;
const uint SIMPLE_SNOW = 2;
uniform uint comodel = 1; //FIXED_COROTATED;

uniform double IMPLICIT_RATIO = 1.0;
uniform double drag = 0.005;

uniform double crit_c = 0.025;
uniform double crit_s = 0.0075;
uniform double hardening = 10.0;

uniform double semi_implicit_eps = 0.00001;


// FOR EVALUATING CONSTITUTIVE MODELS

dmat2 cofactorMatrix(in dmat2 X) {
	return dmat2(X[1][1], -X[1][0], // column 1
				-X[0][1], X[0][0]); // column 2
}

double innerProduct(in dmat2 X, in dmat2 Y) {
	return X[0][0]*Y[0][0] + X[1][0]*Y[1][0] + X[0][1]*Y[0][1] + X[1][1]*Y[1][1];
}

void PolarDecomp(in dmat2 F, out dmat2 R, out dmat2 S) {
	// calculate the polar decomposition F = RS.

	double x = F[0][0] + F[1][1];
	double y = F[0][1] - F[1][0]; // glsl is column major. This is really F_21 - F_12 in row major notation

	double d = sqrt(x*x + y*y);

	double c = x/d;
	double s = -y/d;
	R = (d == 0.0) ? dmat2(1.0, 0.0, 0.0, 1.0) : dmat2(c, -s, s, c);
	S = transpose(R) * F;
}

void SVD(in dmat2 R, in dmat2 S, out dmat2 U, out double sig1, out double sig2, out dmat2 V) {

	// check if S is diagonal (S is symmetric for sure)
	double c_hat, s_hat;
	
	if (S[1][0] == 0) {
		c_hat = 1.0;
		s_hat = 0.0;
		sig1 = S[0][0];
		sig2 = S[1][1];
	} else {
		double tau = 0.5 * (S[0][0] - S[1][1]);
		double w = sqrt(tau*tau + S[1][0]*S[1][0]);
		double t = (tau > 0) ? S[1][0]/(tau + w) : S[1][0]/(tau - w);
		c_hat = 1.0 / sqrt(t*t + 1.0);
		s_hat = -t * c_hat;
		sig1 = c_hat*c_hat*S[0][0] - 2.0*c_hat*s_hat*S[1][0] + s_hat*s_hat*S[1][1];
		sig2 = s_hat*s_hat*S[0][0] + 2.0*c_hat*s_hat*S[1][0] + c_hat*c_hat*S[1][1];
	}

	double c, s;
	if (sig1 < sig2) {
		// swap the singular values so sig1 > sig2
		double temp = sig1;
		sig1 = sig2;
		sig2 = temp;
		c = -s_hat;
		s = c_hat;
	} else {
		c = c_hat;
		s = s_hat;
	}
	V = dmat2(c, -s, s, c);
	U = R*V;
}



/* end MPM shaders header */