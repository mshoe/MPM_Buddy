#version 450 core
#extension GL_NV_shader_atomic_float : enable

layout (local_size_x = 1024) in;

/*** HEADER ***/

void main() {

	uint pid = gl_GlobalInvocationID.x;
	uint N = points.length();
	if (pid > N) {
		return;
	}

	vec2 xp = points[pid].x;

	int botLeftNode_i = int(floor(xp.x)) - 1;
	int botLeftNode_j = int(floor(xp.y)) - 1;

	for (int i = 0; i <= 3; ++i) {
		for (int j = 0; j <= 3; ++j) {
			int curNode_i = botLeftNode_i + i;
			int curNode_j = botLeftNode_j + j;
			float inb = 1.0;
			InBounds(curNode_i, curNode_j, inb);

			vec2 dpg = vec2(curNode_i, curNode_j) - xp;
			float dx = -dpg.x; // sign matters for gradient
			float dy = -dpg.y;
			float wpg = BSpline(dx) * BSpline(dy);
			vec2 wpgGrad = vec2(BSplineSlope(dx) * BSpline(dy),
								BSpline(dx) * BSplineSlope(dy));

			atomicAdd(nodes[curNode_i][curNode_j].m, wpg * points[pid].m);

			barrier();

			vec2 momentumAdd = wpg * points[pid].m * (points[pid].v + points[pid].B * Dp_inv * dpg);
			atomicAdd(nodes[curNode_i][curNode_j].momentum.x, momentumAdd.x);
			atomicAdd(nodes[curNode_i][curNode_j].momentum.y, momentumAdd.y);

			barrier();

			vec2 forceAdd = -points[pid].vol * points[pid].P * transpose(points[pid].Fe) * wpgGrad;
			atomicAdd(nodes[curNode_i][curNode_j].force.x, forceAdd.x);
			atomicAdd(nodes[curNode_i][curNode_j].force.y, forceAdd.y);

			barrier();
		}
	}
}